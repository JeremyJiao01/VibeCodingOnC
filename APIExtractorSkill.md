# C Module API Extractor

## Purpose

Extract detailed API documentation for each C module, generating individual reference files for agent consumption during coding tasks. This is the **second step** in the modular API documentation system.

**Role in the overall workflow:**
- Previous skill (SummarySkill): Generated `module_index.md` (navigation layer)
- **This skill**: Generate `api/{module}.md` (detailed API documentation for each module)
- Coordinated by: A top-level command that chains these skills together

## Usage

When user requests to "extract module APIs" or "generate API documentation" for a C project, use this skill to:
1. Read `docs/module_index.md` to get the list of modules
2. For each module, extract complete API information using LSP
3. Generate detailed API documentation with tiered presentation (Public + Internal)
4. Output as individual `docs/api/{module}.md` files

---

## Implementation Steps

### Step 1: Read Module List

**Read the module index file:**
```bash
# The module list was generated by SummarySkill
cat docs/module_index.md
```

**Extract module names** from the index file. Each module entry looks like:
```markdown
### fan_control
**Keyword:** Fan Thermal Management
**Files:** `fan_control.c`, `fan_control.h`
```

Parse all module names into a list for processing.

---

### Step 2: Extract API Information for Each Module

**CRITICAL: Use Task tool to create an independent sub-agent for each module**

This ensures context isolation and allows parallel processing.

For each module, perform the following extraction **using LSP**:

#### 2.1 Extract Public APIs (from .h file)

If the .h file exists, use LSP to extract:

**Functions:**
```
- Function name
- Return type
- Parameter list (names and types)
- Function documentation comments (if available)
```

**Data Structures:**
```
- struct definitions with field types and names
- enum definitions with all values
- typedef definitions
```

**Macros:**
```
- #define constants
- Function-like macros
```

**Global Variables:**
```
- extern variable declarations
```

#### 2.2 Extract Internal Implementation (from .c file)

Use LSP to extract:

**Static Functions:**
```
- Function name only
- First line of comment (if available)
- Line number range in source file
```

**Static Variables:**
```
- Variable name
- Type
- Line number in source file
```

**Note:** For internal items, we only need **lightweight metadata** (name + location), not full documentation.

---

### Step 3: Generate API Documentation (Isolated Context)

**CRITICAL: Use Task tool to create an independent sub-agent for each module**

For each module, launch a separate documentation generation agent:

```python
Task(
  subagent_type: "general-purpose",
  description: f"Generate API doc for {module_name}",
  prompt: f"""
Generate a comprehensive API reference document for this C module.

Module Name: {module_name}
Files: {module_name}.c, {module_name}.h

=== PUBLIC APIs (from .h) ===
{public_functions_with_signatures}
{structs_and_enums}
{macros}
{global_variables}

=== INTERNAL IMPLEMENTATION (from .c) ===
Static Functions: {list_of_static_function_names_with_line_numbers}
Static Variables: {list_of_static_variables_with_line_numbers}

Module Summary (from module_index.md):
Keyword: {keyword}
Description: {description}

---

Generate the API documentation following this structure:

# {module_name} API Reference

**Keyword:** {keyword}
**Files:** `{module_name}.c`, `{module_name}.h`

## Overview
{2-3 sentence description from module summary}

---

## Public APIs

Group functions by category (Initialization, Control, Status Query, etc.)

For EACH public function:
### {function_name}()
```c
{full_function_signature}
```
**Description:** {What does this function do? When should it be used?}
**Parameters:**
  - `{param_name}`: {type} - {description}
**Returns:** {return_value_meaning}
**Example:**
```c
{short_usage_example}
```

---

For EACH data structure:
### `{struct_name}`
```c
{full_struct_definition}
```
**Purpose:** {Why does this struct exist?}
**Fields:**
  - `{field_name}`: {type} - {description}

---

## Internal Functions (For Reference Only)

**说明：** 这些是 static 函数或未在 .h 中暴露的函数。通常不应直接调用，但了解它们有助于理解模块的完整能力。

**如果你需要使用这些函数：**
- 优先检查是否可以通过 public API 间接实现
- 考虑在 .h 中添加声明（使其成为 public API）
- 或在 .c 中添加 extern 声明（谨慎使用）

### Internal Functions List:
- `{function_name}()` - {one_line_description} (Location: `{module}.c:{line_start}-{line_end}`)
- ...

### Internal Variables:
- `static {type} {var_name}` - {one_line_description} (Location: `{module}.c:{line}`)
- ...

**需要详细了解这些内部实现？** 请直接阅读源文件：`{module_name}.c`

---

## Dependencies

**Requires (modules this module depends on):**
- `{module_name}` - {why}

**Used by (modules that use this module):**
- `{module_name}` - {why}

{Note: This information may need to be inferred from #include statements or left for manual completion}

---

## Usage Example

```c
// Complete usage example showing typical workflow
{multi_line_example_code}
```

---

Rules for documentation generation:
1. Use clear, simple language
2. Focus on "what" and "when to use", not "how it's implemented"
3. Provide concrete examples for each function
4. Keep internal section brief (just names and locations)
5. If documentation comments exist in source, incorporate them
6. If no documentation exists, infer from function names and signatures
"""
)
```

**Why Task tool is required:**
- ✅ Each sub-agent processes one module independently
- ✅ Can run multiple documentation generations in parallel
- ✅ Fresh context for each module
- ✅ Prevents cross-contamination of API descriptions

---

### Step 4: Collect Results and Write API Files

**Workflow:**
1. Wait for all sub-agents to complete their documentation generation
2. For each module, receive the generated markdown content
3. Write to individual files: `docs/api/{module_name}.md`

**Implementation note:**
- Create `docs/api/` directory if it doesn't exist
- You can process modules in parallel (5-10 at a time)
- Verify each generated file is valid markdown and meets size expectations

---

## Output Format: `docs/api/{module}.md`

**Structure Overview:**

```markdown
# {module_name} API Reference
  ├─ Header (keyword, files, overview)
  ├─ Public APIs (80% of content)
  │   ├─ Functions (grouped by category)
  │   ├─ Data Structures
  │   ├─ Enums
  │   └─ Macros
  ├─ Internal Functions (15% of content)
  │   ├─ Function list (name + location)
  │   └─ Variable list (name + location)
  ├─ Dependencies (5% of content)
  └─ Usage Example
```

**Size expectations:**
- Small module (5 APIs): ~500 lines
- Medium module (15 APIs): ~1500 lines
- Large module (30 APIs): ~3000 lines

**File location:**
```
docs/api/{module_name}.md
```

---

## Detailed Output Template

### Header Section
```markdown
# {module_name} API Reference

**Keyword:** {keyword_from_module_index}
**Files:** `{module_name}.c`, `{module_name}.h`

## Overview

{2-3 sentence description from module summary. Explain what problem this module solves and when to use it.}

---
```

### Public APIs Section

**Function documentation template:**
```markdown
## Public APIs

Functions are grouped by category for easier navigation.

### Initialization

#### `fan_init()`
```c
int fan_init(void);
```
**Description:** 初始化风扇控制模块，配置 PWM 外设和转速传感器输入。必须在使用其他 fan 函数之前调用。

**Parameters:** None

**Returns:**
- `0` - 初始化成功
- `-1` - 初始化失败（PWM 配置错误或传感器无响应）

**Usage Context:** 在系统启动时调用一次，通常在 `main()` 的硬件初始化阶段。

**Example:**
```c
if (fan_init() != 0) {
    printf("Error: Fan initialization failed\n");
    return -1;
}
```

---

#### `fan_deinit()`
```c
void fan_deinit(void);
```
**Description:** 关闭风扇并释放相关资源，将 PWM 输出设置为 0。

**Parameters:** None

**Returns:** void

**Usage Context:** 系统关闭前调用，或需要完全禁用风扇功能时。

**Example:**
```c
// 系统关闭流程
fan_deinit();
```

---

### Control Functions

#### `fan_set_mode()`
```c
int fan_set_mode(fan_mode_t mode);
```
**Description:** 切换风扇工作模式。支持自动调速、手动控制和关闭三种模式。

**Parameters:**
  - `mode`: `fan_mode_t` - 目标工作模式
    - `FAN_MODE_AUTO` - 根据温度传感器自动调整转速
    - `FAN_MODE_MANUAL` - 由用户通过 `fan_set_speed()` 手动控制
    - `FAN_MODE_OFF` - 停止风扇

**Returns:**
- `0` - 模式切换成功
- `-1` - 无效的模式参数

**Usage Context:** 在需要改变风扇控制策略时调用。例如，正常运行时使用 AUTO 模式，测试时使用 MANUAL 模式。

**Example:**
```c
// 启动自动温控
if (fan_set_mode(FAN_MODE_AUTO) != 0) {
    printf("Failed to set fan to auto mode\n");
}

// 测试时手动控制
fan_set_mode(FAN_MODE_MANUAL);
fan_set_speed(50);  // 50% 转速
```

---
```

**Data structure documentation template:**
```markdown
### Data Structures

#### `fan_mode_t`
```c
typedef enum {
    FAN_MODE_OFF = 0,     // 风扇关闭
    FAN_MODE_AUTO = 1,    // 自动温控模式
    FAN_MODE_MANUAL = 2   // 手动控制模式
} fan_mode_t;
```
**Purpose:** 定义风扇的三种工作模式。

**Values:**
  - `FAN_MODE_OFF` (0) - 风扇完全停止，PWM 输出为 0
  - `FAN_MODE_AUTO` (1) - 温度自动调节，根据 thermal_manager 提供的温度值调整转速
  - `FAN_MODE_MANUAL` (2) - 手动设置转速，通过 `fan_set_speed()` 控制

**Usage:** 传递给 `fan_set_mode()` 函数。

---

#### `fan_config_t`
```c
typedef struct {
    uint8_t min_speed;       // 最低转速限制 (0-100)
    uint8_t max_speed;       // 最高转速限制 (0-100)
    uint16_t pwm_frequency;  // PWM 频率 (Hz)
    bool enable_tachometer;  // 是否启用转速反馈
} fan_config_t;
```
**Purpose:** 风扇配置参数，用于自定义风扇的工作范围和特性。

**Fields:**
  - `min_speed`: uint8_t - 最低转速百分比（0-100），防止风扇转速过低导致停转
  - `max_speed`: uint8_t - 最高转速百分比（0-100），保护风扇不超速运行
  - `pwm_frequency`: uint16_t - PWM 信号频率（单位 Hz），典型值 25000（25kHz）
  - `enable_tachometer`: bool - 是否启用转速传感器反馈，用于闭环控制

**Usage:** 通常在初始化后通过配置函数设置（如果有 `fan_configure()` API）。

---
```

### Internal Functions Section

```markdown
## Internal Functions (For Reference Only)

**说明：** 这些是 static 函数或未在 .h 中暴露的函数/变量。通常不应直接调用，但了解它们有助于理解模块的完整能力。

**如果你需要使用这些函数：**
1. **优先方案：** 检查是否可以通过现有 public API 间接实现你的需求
2. **扩展接口：** 考虑在 .h 中添加新的 public API，并在 .c 中实现
3. **临时方案：** 在调用代码中添加 `extern` 声明（不推荐，破坏封装性）

### Internal Functions List:

- `fan_update_pwm()` - 根据目标转速更新 PWM 占空比 (Location: `fan_control.c:145-167`)
- `fan_read_tachometer()` - 读取转速传感器的原始脉冲计数 (Location: `fan_control.c:169-189`)
- `fan_thermal_control_loop()` - 自动模式下的 PID 温控算法主循环 (Location: `fan_control.c:191-245`)
- `fan_calculate_duty_cycle()` - 将转速百分比转换为 PWM 占空比 (Location: `fan_control.c:247-260`)

### Internal Variables:

- `static fan_state_t g_fan_state` - 当前风扇状态（模式、转速等） (Location: `fan_control.c:32`)
- `static uint8_t g_last_speed` - 上次设置的目标转速 (Location: `fan_control.c:33`)
- `static uint32_t g_pwm_period` - PWM 定时器周期值，由频率计算得出 (Location: `fan_control.c:34`)

**需要详细了解这些内部实现？** 请直接阅读源文件：`fan_control.c`

---
```

### Dependencies Section

```markdown
## Dependencies

**This module requires (direct dependencies):**
- `pwm_driver` - 用于生成 PWM 控制信号
- `timer` - 用于转速传感器的脉冲计数
- `gpio` - 用于转速传感器输入引脚配置

**This module is used by (reverse dependencies):**
- `thermal_manager` - 温度管理模块调用本模块进行冷却控制
- `fault_handler` - 故障保护模块在过热时强制启动风扇
- `system_init` - 系统初始化时调用 `fan_init()`

**Note:** 依赖关系可能需要通过分析 #include 语句或手工补充。

---
```

### Usage Example Section

```markdown
## Complete Usage Example

```c
#include "fan_control.h"
#include "thermal_manager.h"

int main(void) {
    // 1. 系统初始化阶段
    if (fan_init() != 0) {
        printf("Fan initialization failed!\n");
        return -1;
    }

    // 2. 配置为自动模式
    fan_set_mode(FAN_MODE_AUTO);

    // 3. 主循环
    while (1) {
        // 在自动模式下，风扇会根据温度自动调整
        // 查询当前转速
        uint8_t current_speed = fan_get_speed();

        if (current_speed == 255) {
            // 转速传感器故障
            printf("Warning: Fan tachometer fault!\n");
        }

        // 如果温度过高，切换到手动全速模式
        if (thermal_get_temperature() > 85.0f) {
            fan_set_mode(FAN_MODE_MANUAL);
            fan_set_speed(100);  // 全速运行
        }

        delay_ms(1000);
    }

    // 4. 系统关闭
    fan_deinit();

    return 0;
}
```

**运行流程：**
1. 初始化风扇控制模块
2. 设置为自动温控模式
3. 主循环中监控转速和温度
4. 温度过高时切换到手动全速
5. 系统关闭时清理资源

---
```

---

## LSP Command Details

Use these LSP commands to extract symbol information:

### Extract Function Signatures
```
vscode.executeDocumentSymbolProvider(uri)
  → Returns: SymbolInformation[]
  → Filter: kind == SymbolKind.Function
  → Extract: name, range, parameters (from signature)
```

### Extract Struct/Enum Definitions
```
vscode.executeDocumentSymbolProvider(uri)
  → Filter: kind == SymbolKind.Struct || kind == SymbolKind.Enum
  → Extract: name, range, children (fields/values)
```

### Extract Documentation Comments
```
Read the line(s) immediately before function/struct definition
Look for patterns:
  - `/** ... */` (Doxygen style)
  - `/* ... */` (Standard C comment)
  - `// ...` (Single-line comments)
```

### Find Static Functions
```
vscode.executeDocumentSymbolProvider(uri) on .c file
  → Filter functions not present in .h file
  → Or: grep for `^static.*\(` pattern
```

---

## Error Handling

### If .h file is missing:
- Note in documentation: "Header-only: No (internal module)"
- Proceed with .c file only
- All functions are considered "internal"

### If LSP fails:
- **Fallback strategy**: Use Grep tool to extract:
  - Function declarations: `grep -n "^[a-zA-Z_].*\(" file.h`
  - Struct definitions: `grep -n "^typedef struct" file.h`
- Parse manually using regex patterns
- Generate basic documentation without detailed parameter info

### If no functions found:
- Check if module is data-only (structs/enums/macros)
- Generate documentation focused on data structures
- Note: "Configuration Module - No function APIs"

---

## Output Location

Save generated API documentation to:
```
./docs/api/{module_name}.md
```

**Directory structure after this skill:**
```
docs/
  ├── module_index.md       # Generated by SummarySkill
  └── api/                  # Generated by THIS skill
      ├── fan_control.md
      ├── relay_control.md
      ├── sensor_manager.md
      └── ...
```

If `docs/api/` doesn't exist, create it.

---

## Success Criteria

A well-generated `api/{module}.md` should:
1. ✅ Include all public APIs with complete signatures and descriptions
2. ✅ Have usage examples for each major function
3. ✅ Include data structure definitions with field descriptions
4. ✅ List internal functions with source file locations (lightweight)
5. ✅ Be structured for easy navigation (grouped by category)
6. ✅ **Each module analyzed using separate Task tool invocation** (context isolation)
7. ✅ File size appropriate for agent consumption (<5000 lines for large modules)
8. ✅ Internal section is brief (5-15% of total content)
9. ✅ No cross-references to other module implementation details
10. ✅ Include at least one complete usage example

**Quality checks:**
- [ ] All public functions have examples
- [ ] All structs have field descriptions
- [ ] Internal section exists and is concise
- [ ] File is valid markdown
- [ ] Links to source files are correct

---

## Usage in Claude Code

To use this skill, tell Claude Code:
```
"Use the API Extractor skill to generate detailed API documentation for all modules."
```

Claude Code will then:
1. Read `docs/module_index.md` to get the list of modules
2. For each module:
   - Extract public APIs from .h using LSP (detailed)
   - Extract internal functions from .c using LSP (names + locations)
   - Launch independent sub-agent to generate documentation
3. Write individual `docs/api/{module}.md` files
4. Verify all files are generated successfully

**Prerequisites:**
- `docs/module_index.md` must exist (generated by SummarySkill)
- VSCode LSP must be available for symbol extraction

---

## Example Workflow

```bash
# 1. Main agent: Read module list
$ cat docs/module_index.md
# Sees: fan_control, relay_control, sensor_manager, ...

# 2. Main agent: Extract LSP symbols for fan_control
# Open fan_control.h → LSP symbols → See: fan_init(), fan_set_mode(), fan_get_speed(), struct fan_config_t
# Open fan_control.c → LSP symbols → See: static fan_update_pwm(), static fan_read_tachometer()

# 3. Main agent: Launch Task tool for fan_control documentation
Task(
  subagent_type: "general-purpose",
  description: "Generate API doc for fan_control",
  prompt: "Generate comprehensive API documentation...\nPublic APIs: fan_init(), fan_set_mode()...\nInternal: fan_update_pwm()...\n"
)

# 3a. Sub-agent (independent context): Generates structured markdown
# Sub-agent output: Complete API documentation with examples

# 4. Main agent: Write to file
Write file: docs/api/fan_control.md (1500 lines)

# 5. Main agent: Repeat for next module (parallel or sequential)
Task(
  subagent_type: "general-purpose",
  description: "Generate API doc for relay_control",
  ...
)

# 6. All modules processed
# Result: docs/api/ contains 50+ individual API reference files
```

**Key point:** Each module's documentation is generated by a separate sub-agent = context isolation + parallel processing.

---

## Integration with Overall System

**Three-skill workflow:**

1. **SummarySkill** (navigation layer)
   - Input: Source code (.c/.h files)
   - Output: `docs/module_index.md`
   - Purpose: Quick module discovery

2. **APIExtractorSkill** (this skill - detail layer)
   - Input: `docs/module_index.md` + source code
   - Output: `docs/api/{module}.md` (one per module)
   - Purpose: Detailed API reference for coding

3. **Future: CodingSkill** (consumption layer)
   - Input: Design document + `docs/module_index.md` + `docs/api/*.md`
   - Output: Implementation code
   - Process:
     - Read module_index.md → Find relevant modules
     - Read api/{module}.md → Get API details
     - Write code using documented APIs

**The complete agent workflow:**
```
User: "实现温度监控和风扇控制功能"
  ↓
CodingSkill:
  1. Read docs/module_index.md
     → Find: thermal_manager, fan_control, sensor_manager
  2. Read docs/api/fan_control.md
     → Learn: fan_init(), fan_set_mode(), fan_get_speed()
  3. Read docs/api/sensor_manager.md
     → Learn: sensor_read_temperature()
  4. Write code using these APIs
  5. If needed: Check internal functions for advanced usage
```

---
